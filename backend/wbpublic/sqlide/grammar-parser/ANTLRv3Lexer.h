/** \file
 *  This C header file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : ANTLRv3.g
 *     -                            On : 2014-09-17 15:06:24
 *     -                 for the lexer : ANTLRv3LexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
 * The lexer 
ANTLRv3Lexer

has the callable functions (rules) shown below,
 * which will invoke the code for the associated rule in the source grammar
 * assuming that the input stream is pointing to a token/text stream that could begin
 * this rule.
 *
 * For instance if you call the first (topmost) rule in a parser grammar, you will
 * get the results of a full parse, but calling a rule half way through the grammar will
 * allow you to pass part of a full token stream to the parser, such as for syntax checking
 * in editors and so on.
 *
 * The parser entry points are called indirectly (by function pointer to function) via
 * a parser context typedef pANTLRv3Lexer, which is returned from a call to ANTLRv3LexerNew().
 *
 * As this is a generated lexer, it is unlikely you will call it 'manually'. However
 * the methods are provided anyway.
 *
 * The methods in pANTLRv3Lexer are  as follows:
 *
 *  - 
 void
      pANTLRv3Lexer->AT(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->BANG(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->FRAGMENT(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->LABEL_ASSIGN(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->LIST_LABEL_ASSIGN(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->RANGE(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->RET(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->REWRITE(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->ROOT(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->SCOPE(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->TREE_BEGIN(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__72(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__73(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__74(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__75(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__76(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__77(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__78(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__79(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__80(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__81(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__82(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__83(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__84(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__85(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__86(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__87(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__88(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__89(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__90(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__91(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__92(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__93(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__94(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__95(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->T__96(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->OPTIONS_SYM(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->TOKENS_SYM(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->SRC_SYM(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->FINALLY_SYM(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->CATCH_SYM(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->SL_COMMENT(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->ML_COMMENT(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->CHAR_LITERAL(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->STRING_LITERAL(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->LITERAL_CHAR(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->DOUBLE_QUOTE_STRING_LITERAL(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->DOUBLE_ANGLE_STRING_LITERAL(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->ESC(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->XDIGIT(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->INT(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->ARG_ACTION(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->NESTED_ARG_ACTION(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->ACTION(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->NESTED_ACTION(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->ACTION_CHAR_LITERAL(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->ACTION_STRING_LITERAL(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->ACTION_ESC(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->OPTIONS(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->TOKENS(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->SRC(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->TOKEN_REF(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->RULE_REF(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->WS(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->WS_LOOP(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->DOC_COMMENT(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->SEMPRED(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->GATED_SEMPRED(pANTLRv3Lexer)
 *  - 
 void
      pANTLRv3Lexer->Tokens(pANTLRv3Lexer)
 *
 * The return type for any particular rule is of course determined by the source
 * grammar file.
 */
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef	_ANTLRv3Lexer_H
#define _ANTLRv3Lexer_H
/* =============================================================================
 * Standard antlr3 C runtime definitions
 */
#include    <antlr3.h>

/* End of standard antlr 3 runtime definitions
 * =============================================================================
 */

#ifdef __cplusplus
extern "C" {
#endif

// Forward declare the context typedef so that we can use it before it is
// properly defined. Delegators and delegates (from import statements) are
// interdependent and their context structures contain pointers to each other
// C only allows such things to be declared if you pre-declare the typedef.
//
typedef struct ANTLRv3Lexer_Ctx_struct ANTLRv3Lexer, * pANTLRv3Lexer;



#ifndef _WIN32
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wparentheses"
#ifdef __APPLE__
// Comparison of unsigned expression >= 0 is always true.
#pragma GCC diagnostic ignored "-Wtautological-compare"
#else
#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ > 6 )
#pragma GCC diagnostic ignored "-Wtype-limits"
#endif
#endif
#else
#pragma warning(disable:4296) // Condition is always true.
#endif


#ifdef	ANTLR3_WINDOWS
// Disable: Unreferenced parameter,							- Rules with parameters that are not used
//          constant conditional,							- ANTLR realizes that a prediction is always true (synpred usually)
//          initialized but unused variable					- tree rewrite variables declared but not needed
//          Unreferenced local variable						- lexer rule declares but does not always use _type
//          potentially unitialized variable used			- retval always returned from a rule
//			unreferenced local function has been removed	- susually getTokenNames or freeScope, they can go without warnigns
//
// These are only really displayed at warning level /W4 but that is the code ideal I am aiming at
// and the codegen must generate some of these warnings by necessity, apart from 4100, which is
// usually generated when a parser rule is given a parameter that it does not use. Mostly though
// this is a matter of orthogonality hence I disable that one.
//
#pragma warning( disable : 4100 )
#pragma warning( disable : 4101 )
#pragma warning( disable : 4127 )
#pragma warning( disable : 4189 )
#pragma warning( disable : 4505 )
#pragma warning( disable : 4701 )
#endif

/** Context tracking structure for 
ANTLRv3Lexer

 */
struct ANTLRv3Lexer_Ctx_struct
{
    /** Built in ANTLR3 context tracker contains all the generic elements
     *  required for context tracking.
     */
    pANTLR3_LEXER    pLexer;

     void
     (*mAT)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mBANG)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mFRAGMENT)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mLABEL_ASSIGN)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mLIST_LABEL_ASSIGN)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mRANGE)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mRET)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mREWRITE)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mROOT)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mSCOPE)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mTREE_BEGIN)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__72)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__73)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__74)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__75)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__76)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__77)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__78)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__79)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__80)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__81)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__82)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__83)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__84)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__85)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__86)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__87)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__88)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__89)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__90)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__91)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__92)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__93)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__94)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__95)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mT__96)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mOPTIONS_SYM)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mTOKENS_SYM)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mSRC_SYM)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mFINALLY_SYM)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mCATCH_SYM)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mSL_COMMENT)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mML_COMMENT)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mCHAR_LITERAL)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mSTRING_LITERAL)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mLITERAL_CHAR)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mDOUBLE_QUOTE_STRING_LITERAL)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mDOUBLE_ANGLE_STRING_LITERAL)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mESC)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mXDIGIT)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mINT)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mARG_ACTION)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mNESTED_ARG_ACTION)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mACTION)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mNESTED_ACTION)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mACTION_CHAR_LITERAL)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mACTION_STRING_LITERAL)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mACTION_ESC)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mOPTIONS)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mTOKENS)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mSRC)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mTOKEN_REF)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mRULE_REF)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mWS)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mWS_LOOP)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mDOC_COMMENT)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mSEMPRED)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mGATED_SEMPRED)	(struct ANTLRv3Lexer_Ctx_struct * ctx);

     void
     (*mTokens)	(struct ANTLRv3Lexer_Ctx_struct * ctx);
    const char * (*getGrammarFileName)();
    void            (*reset)  (struct ANTLRv3Lexer_Ctx_struct * ctx);
    void	    (*free)   (struct ANTLRv3Lexer_Ctx_struct * ctx);
};

// Function protoypes for the constructor functions that external translation units
// such as delegators and delegates may wish to call.
//
ANTLR3_API pANTLRv3Lexer ANTLRv3LexerNew         (
pANTLR3_INPUT_STREAM
 instream);
ANTLR3_API pANTLRv3Lexer ANTLRv3LexerNewSSD      (
pANTLR3_INPUT_STREAM
 instream, pANTLR3_RECOGNIZER_SHARED_STATE state);

/** Symbolic definitions of all the tokens that the 
lexer
 will work with.
 * \{
 *
 * Antlr will define EOF, but we can't use that as it it is too common in
 * in C header files and that would be confusing. There is no way to filter this out at the moment
 * so we just undef it here for now. That isn't the value we get back from C recognizers
 * anyway. We are looking for ANTLR3_TOKEN_EOF.
 */
#ifdef	EOF
#undef	EOF
#endif
#ifdef	Tokens
#undef	Tokens
#endif
#define EOF      -1
#define T__72      72
#define T__73      73
#define T__74      74
#define T__75      75
#define T__76      76
#define T__77      77
#define T__78      78
#define T__79      79
#define T__80      80
#define T__81      81
#define T__82      82
#define T__83      83
#define T__84      84
#define T__85      85
#define T__86      86
#define T__87      87
#define T__88      88
#define T__89      89
#define T__90      90
#define T__91      91
#define T__92      92
#define T__93      93
#define T__94      94
#define T__95      95
#define T__96      96
#define ACTION      4
#define ACTION_CHAR_LITERAL      5
#define ACTION_ESC      6
#define ACTION_STRING_LITERAL      7
#define ALT      8
#define ARG      9
#define ARGLIST      10
#define ARG_ACTION      11
#define AT      12
#define BACKTRACK_SEMPRED      13
#define BANG      14
#define BLOCK      15
#define CATCH_SYM      16
#define CHAR_LITERAL      17
#define CHAR_RANGE      18
#define CLOSURE      19
#define COMBINED_GRAMMAR      20
#define DOC_COMMENT      21
#define DOUBLE_ANGLE_STRING_LITERAL      22
#define DOUBLE_QUOTE_STRING_LITERAL      23
#define EOA      24
#define EOB      25
#define EORu      26
#define EPSILON      27
#define ESC      28
#define FINALLY_SYM      29
#define FRAGMENT      30
#define GATED_SEMPRED      31
#define ID      32
#define INT      33
#define LABEL      34
#define LABEL_ASSIGN      35
#define LEXER      36
#define LEXER_GRAMMAR      37
#define LIST_LABEL_ASSIGN      38
#define LITERAL_CHAR      39
#define ML_COMMENT      40
#define NESTED_ACTION      41
#define NESTED_ARG_ACTION      42
#define OPTIONAL      43
#define OPTIONS      44
#define OPTIONS_SYM      45
#define PARSER      46
#define PARSER_GRAMMAR      47
#define POSITIVE_CLOSURE      48
#define RANGE      49
#define RET      50
#define REWRITE      51
#define ROOT      52
#define RULE      53
#define RULE_REF      54
#define SCOPE      55
#define SEMPRED      56
#define SL_COMMENT      57
#define SRC      58
#define SRC_SYM      59
#define STRING_LITERAL      60
#define SYNPRED      61
#define SYN_SEMPRED      62
#define TEMPLATE      63
#define TOKENS      64
#define TOKENS_SYM      65
#define TOKEN_REF      66
#define TREE_BEGIN      67
#define TREE_GRAMMAR      68
#define WS      69
#define WS_LOOP      70
#define XDIGIT      71
#ifdef	EOF
#undef	EOF
#define	EOF	ANTLR3_TOKEN_EOF
#endif

#ifndef TOKENSOURCE
#define TOKENSOURCE(lxr) lxr->pLexer->rec->state->tokSource
#endif

/* End of token definitions for ANTLRv3Lexer
 * =============================================================================
 */
/** } */

#ifdef __cplusplus
}
#endif

#endif

/* END - Note:Keep extra line feed to satisfy UNIX systems */
